use std::fs;
use std::io;
use std::path::Path;
use std::process::Command;

use tracing::{error, info, warn};

pub const CACHE_FILE_PATH: &str = "/var/cache/envycontrol/cache.json";
pub const BLACKLIST_PATH: &str = "/etc/modprobe.d/blacklist-nvidia.conf";
pub const UDEV_INTEGRATED_PATH: &str = "/etc/udev/rules.d/50-remove-nvidia.rules";
pub const UDEV_PM_PATH: &str = "/etc/udev/rules.d/80-nvidia-pm.rules";
pub const XORG_PATH: &str = "/etc/X11/xorg.conf";
pub const EXTRA_XORG_PATH: &str = "/etc/X11/xorg.conf.d/10-nvidia.conf";
pub const MODESET_PATH: &str = "/etc/modprobe.d/nvidia.conf";
pub const SDDM_XSETUP_PATH: &str = "/usr/share/sddm/scripts/Xsetup";
pub const LIGHTDM_SCRIPT_PATH: &str = "/etc/lightdm/nvidia.sh";
pub const LIGHTDM_CONFIG_PATH: &str = "/etc/lightdm/lightdm.conf.d/20-nvidia.conf";

const BLACKLIST_CONTENT: &str = r#"# Automatically generated by Kaede

blacklist nouveau
blacklist nova_core
blacklist nova_drm
blacklist nvidia
blacklist nvidia_drm
blacklist nvidia_uvm
blacklist nvidia_modeset
blacklist nvidia_current
blacklist nvidia_current_drm
blacklist nvidia_current_uvm
blacklist nvidia_current_modeset
blacklist i2c_nvidia_gpu
alias nouveau off
alias nova_core off
alias nova_drm off
alias nvidia off
alias nvidia_drm off
alias nvidia_uvm off
alias nvidia_modeset off
alias nvidia_current off
alias nvidia_current_drm off
alias nvidia_current_uvm off
alias nvidia_current_modeset off
alias i2c_nvidia_gpu off
"#;

const UDEV_INTEGRATED: &str = r#"# Automatically generated by Kaede

# Remove NVIDIA USB xHCI Host Controller devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x0c0330", ATTR{power/control}="auto", ATTR{remove}="1"

# Remove NVIDIA USB Type-C UCSI devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x0c8000", ATTR{power/control}="auto", ATTR{remove}="1"

# Remove NVIDIA Audio devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x040300", ATTR{power/control}="auto", ATTR{remove}="1"

# Remove NVIDIA VGA/3D controller devices
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x03[0-9]*", ATTR{power/control}="auto", ATTR{remove}="1"
"#;

const UDEV_PM_CONTENT: &str = r#"# Automatically generated by Kaede

# Remove NVIDIA USB xHCI Host Controller devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x0c0330", ATTR{remove}="1"

# Remove NVIDIA USB Type-C UCSI devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x0c8000", ATTR{remove}="1"

# Remove NVIDIA Audio devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x040300", ATTR{remove}="1"

# Enable runtime PM for NVIDIA VGA/3D controller devices on driver bind
ACTION=="bind", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x030000", TEST=="power/control", ATTR{power/control}="auto"
ACTION=="bind", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x030200", TEST=="power/control", ATTR{power/control}="auto"

# Disable runtime PM for NVIDIA VGA/3D controller devices on driver unbind
ACTION=="unbind", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x030000", TEST=="power/control", ATTR{power/control}="on"
ACTION=="unbind", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x030200", TEST=="power/control", ATTR{power/control}="on"
"#;

const XORG_INTEL: &str = r#"# Automatically generated by Kaede

Section "ServerLayout"
    Identifier "layout"
    Screen 0 "nvidia"
    Inactive "intel"
EndSection

Section "Device"
    Identifier "nvidia"
    Driver "nvidia"
    BusID "{}"
EndSection

Section "Screen"
    Identifier "nvidia"
    Device "nvidia"
    Option "AllowEmptyInitialConfiguration"
EndSection

Section "Device"
    Identifier "intel"
    Driver "modesetting"
EndSection

Section "Screen"
    Identifier "intel"
    Device "intel"
EndSection
"#;

const XORG_AMD: &str = r#"# Automatically generated by Kaede

Section "ServerLayout"
    Identifier "layout"
    Screen 0 "nvidia"
    Inactive "amdgpu"
EndSection

Section "Device"
    Identifier "nvidia"
    Driver "nvidia"
    BusID "{}"
EndSection

Section "Screen"
    Identifier "nvidia"
    Device "nvidia"
    Option "AllowEmptyInitialConfiguration"
EndSection

Section "Device"
    Identifier "amdgpu"
    Driver "amdgpu"
EndSection

Section "Screen"
    Identifier "amd"
    Device "amdgpu"
EndSection
"#;

const EXTRA_XORG_CONTENT: &str = r#"# Automatically generated by Kaede

Section "OutputClass"
    Identifier "nvidia"
    MatchDriver "nvidia-drm"
    Driver "nvidia"
"#;

const FORCE_COMP: &str = "    Option \"ForceCompositionPipeline\" \"true\"\n";
const COOLBITS_FMT: &str = "    Option \"Coolbits\" \"{}\"\n";

const MODESET_CONTENT: &str = r#"# Automatically generated by Kaede

options nvidia-drm modeset=1
options nvidia NVreg_UsePageAttributeTable=1 NVreg_InitializeSystemMemoryAllocations=0
"#;

const MODESET_CURRENT_CONTENT: &str = r#"# Automatically generated by Kaede

options nvidia-current-drm modeset=1
options nvidia-current NVreg_UsePageAttributeTable=1 NVreg_InitializeSystemMemoryAllocations=0
"#;

const MODESET_RTD3_FMT: &str = r#"# Automatically generated by Kaede

options nvidia-drm modeset=1
options nvidia "NVreg_DynamicPowerManagement=0x0{}"
options nvidia NVreg_UsePageAttributeTable=1 NVreg_InitializeSystemMemoryAllocations=0
"#;

const MODESET_CURRENT_RTD3_FMT: &str = r#"# Automatically generated by Kaede

options nvidia-current-drm modeset=1
options nvidia-current "NVreg_DynamicPowerManagement=0x0{}"
options nvidia-current NVreg_UsePageAttributeTable=1 NVreg_InitializeSystemMemoryAllocations=0
"#;

const SDDM_XSETUP_CONTENT: &str = r#"#!/bin/sh
# Xsetup - run as root before the login dialog appears

"#;

const LIGHTDM_CONFIG_CONTENT: &str = r#"# Automatically generated by Kaede

[Seat:*]
display-setup-script=/etc/lightdm/nvidia.sh
"#;

const NVIDIA_XRANDR_SCRIPT: &str = r#"#!/bin/sh
# Automatically generated by Kaede

current=""

xrandr --setprovideroutputsource "{}" NVIDIA-0
xrandr --auto

for next in $(xrandr --listmonitors | grep -E " *[0-9]+:.*" | cut -d" " -f6); do
  [ -z "$current" ] && current=$next && continue
  xrandr --output "$current" --auto --output "$next" --auto --right-of "$current"
  current=$next
done
"#;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum GraphicsMode {
    Integrated,
    Hybrid,
    Nvidia,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DisplayManager {
    Gdm,
    Gdm3,
    Sddm,
    Lightdm,
}

impl DisplayManager {
    fn as_str(self) -> &'static str {
        match self {
            DisplayManager::Gdm => "gdm",
            DisplayManager::Gdm3 => "gdm3",
            DisplayManager::Sddm => "sddm",
            DisplayManager::Lightdm => "lightdm",
        }
    }

    fn from_str(s: &str) -> Option<Self> {
        match s {
            "gdm" => Some(DisplayManager::Gdm),
            "gdm3" => Some(DisplayManager::Gdm3),
            "sddm" => Some(DisplayManager::Sddm),
            "lightdm" => Some(DisplayManager::Lightdm),
            _ => None,
        }
    }
}

#[derive(Debug, Clone)]
pub struct NvidiaSwitchConfig {
    pub mode: GraphicsMode,
    pub display_manager: Option<DisplayManager>,
    pub enable_force_comp: bool,
    pub coolbits_value: Option<i32>,
    pub rtd3_value: Option<i32>,
    pub use_nvidia_current: bool,
}

impl Default for NvidiaSwitchConfig {
    fn default() -> Self {
        Self {
            mode: GraphicsMode::Hybrid,
            display_manager: None,
            enable_force_comp: false,
            coolbits_value: None,
            rtd3_value: None,
            use_nvidia_current: false,
        }
    }
}

pub fn get_current_mode() -> GraphicsMode {
    let blacklist = Path::new(BLACKLIST_PATH).exists();
    let udev_integrated = Path::new(UDEV_INTEGRATED_PATH).exists()
        || Path::new("/lib/udev/rules.d/50-remove-nvidia.rules").exists();
    let xorg = Path::new(XORG_PATH).exists();
    let modeset = Path::new(MODESET_PATH).exists();

    if blacklist && udev_integrated {
        GraphicsMode::Integrated
    } else if xorg && modeset {
        GraphicsMode::Nvidia
    } else {
        GraphicsMode::Hybrid
    }
}

pub fn switch_graphics_mode(config: &NvidiaSwitchConfig) -> Result<(), String> {
    info!("Switching NVIDIA mode to {:?}", config.mode);

    match config.mode {
        GraphicsMode::Integrated => switch_integrated(),
        GraphicsMode::Hybrid => switch_hybrid(config),
        GraphicsMode::Nvidia => switch_nvidia(config),
    }
}

pub fn reset_all() -> Result<(), String> {
    cleanup();
    rebuild_initramfs()?;
    Ok(())
}

pub fn reset_sddm() -> Result<(), String> {
    create_file(SDDM_XSETUP_PATH, SDDM_XSETUP_CONTENT, true)?;
    Ok(())
}

fn switch_integrated() -> Result<(), String> {
    run_systemctl("disable", "nvidia-persistenced.service");

    cleanup();

    create_file(BLACKLIST_PATH, BLACKLIST_CONTENT, false)?;
    create_file(UDEV_INTEGRATED_PATH, UDEV_INTEGRATED, false)?;

    rebuild_initramfs()
}

fn switch_hybrid(config: &NvidiaSwitchConfig) -> Result<(), String> {
    info!(
        "Enable PCI-Express Runtime D3 (RTD3) Power Management: {:?}",
        config.rtd3_value
    );
    cleanup();

    run_systemctl("enable", "nvidia-persistenced.service");

    match config.rtd3_value {
        None => {
            if config.use_nvidia_current {
                create_file(MODESET_PATH, MODESET_CURRENT_CONTENT, false)?;
            } else {
                create_file(MODESET_PATH, MODESET_CONTENT, false)?;
            }
        }
        Some(v) => {
            let content = if config.use_nvidia_current {
                MODESET_CURRENT_RTD3_FMT.replace("{}", &v.to_string())
            } else {
                MODESET_RTD3_FMT.replace("{}", &v.to_string())
            };
            create_file(MODESET_PATH, &content, false)?;
            create_file(UDEV_PM_PATH, UDEV_PM_CONTENT, false)?;
        }
    }

    rebuild_initramfs()
}

fn switch_nvidia(config: &NvidiaSwitchConfig) -> Result<(), String> {
    info!(
        "Enable ForceCompositionPipeline: {}, Coolbits: {:?}",
        config.enable_force_comp, config.coolbits_value
    );

    run_systemctl("enable", "nvidia-persistenced.service");

    cleanup();

    let nvidia_gpu_pci_bus = get_nvidia_gpu_pci_bus()?;
    let igpu_vendor = get_igpu_vendor();

    match igpu_vendor.as_deref() {
        Some("intel") => {
            let content = XORG_INTEL.replace("{}", &nvidia_gpu_pci_bus);
            create_file(XORG_PATH, &content, false)?;
        }
        Some("amd") => {
            let content = XORG_AMD.replace("{}", &nvidia_gpu_pci_bus);
            create_file(XORG_PATH, &content, false)?;
        }
        _ => {
            warn!("Could not determine iGPU vendor; skipping Xorg configuration");
        }
    }

    if config.use_nvidia_current {
        create_file(MODESET_PATH, MODESET_CURRENT_CONTENT, false)?;
    } else {
        create_file(MODESET_PATH, MODESET_CONTENT, false)?;
    }

    if config.enable_force_comp || config.coolbits_value.is_some() {
        let mut extra = String::from(EXTRA_XORG_CONTENT);
        if config.enable_force_comp {
            extra.push_str(FORCE_COMP);
        }
        if let Some(v) = config.coolbits_value {
            extra.push_str(&COOLBITS_FMT.replace("{}", &v.to_string()));
        }
        extra.push_str("EndSection\n");
        create_file(EXTRA_XORG_PATH, &extra, false)?;
    }

    let dm = match config.display_manager.or_else(detect_display_manager) {
        Some(dm) => dm,
        None => {
            warn!("Display Manager detection is not available; skipping DM-specific configuration");
            rebuild_initramfs()?;
            return Ok(());
        }
    };

    if matches!(dm, DisplayManager::Sddm | DisplayManager::Lightdm) {
        let igpu_vendor = igpu_vendor.unwrap_or_default();
        let script = generate_xrandr_script(&igpu_vendor);

        if matches!(dm, DisplayManager::Sddm) {
            if Path::new(SDDM_XSETUP_PATH).exists() {
                info!("Creating Xsetup backup");
                if let Ok(existing) = fs::read_to_string(SDDM_XSETUP_PATH) {
                    let _ = create_file(&format!("{SDDM_XSETUP_PATH}.bak"), &existing, false);
                }
            }
            create_file(SDDM_XSETUP_PATH, &script, true)?;
        } else if matches!(dm, DisplayManager::Lightdm) {
            create_file(LIGHTDM_SCRIPT_PATH, &script, true)?;
            create_file(LIGHTDM_CONFIG_PATH, LIGHTDM_CONFIG_CONTENT, false)?;
        }
    }

    rebuild_initramfs()
}

fn run_systemctl(action: &str, service: &str) {
    let status = Command::new("systemctl")
        .arg(action)
        .arg(service)
        .status();

    match status {
        Ok(status) if status.success() => {
            info!("{action} {service} succeeded");
        }
        Ok(status) => {
            error!(
                "systemctl {action} {service} failed with status: {:?}",
                status.code()
            );
        }
        Err(err) => {
            error!("failed to run systemctl {action} {service}: {err}");
        }
    }
}

fn cleanup() {
    let to_remove = [
        BLACKLIST_PATH,
        UDEV_INTEGRATED_PATH,
        UDEV_PM_PATH,
        XORG_PATH,
        EXTRA_XORG_PATH,
        MODESET_PATH,
        LIGHTDM_SCRIPT_PATH,
        LIGHTDM_CONFIG_PATH,
        "/etc/X11/xorg.conf.d/90-nvidia.conf",
        "/lib/udev/rules.d/50-remove-nvidia.rules",
        "/lib/udev/rules.d/80-nvidia-pm.rules",
    ];

    for path in &to_remove {
        if let Err(err) = fs::remove_file(path).or_else(|e| {
            if e.kind() == io::ErrorKind::NotFound {
                Ok(())
            } else {
                Err(e)
            }
        }) {
            error!("Failed to remove file '{path}': {err}");
        } else {
            info!("Removed file {path}");
        }
    }

    let backup_path = format!("{SDDM_XSETUP_PATH}.bak");
    if Path::new(&backup_path).exists() {
        info!("Restoring Xsetup backup");
        if let Ok(contents) = fs::read_to_string(&backup_path) {
            let _ = create_file(SDDM_XSETUP_PATH, &contents, false);
        }
        if let Err(err) = fs::remove_file(&backup_path) {
            error!("Failed to remove file '{backup_path}': {err}");
        } else {
            info!("Removed file {backup_path}");
        }
    }
}

fn get_nvidia_gpu_pci_bus() -> Result<String, String> {
    let output = Command::new("lspci")
        .output()
        .map_err(|e| format!("failed to run lspci: {e}"))?;
    if !output.status.success() {
        return Err("lspci returned non-zero status".to_string());
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    for line in stdout.lines() {
        let is_nvidia = line.contains("NVIDIA")
            && (line.contains("VGA compatible controller") || line.contains("3D controller"));
        if !is_nvidia {
            continue;
        }

        let pci_bus_id = line
            .split_whitespace()
            .next()
            .unwrap_or_default()
            .replace("0000:", "");
        info!("Found Nvidia GPU at {pci_bus_id}");

        let mut parts = pci_bus_id.split(':');
        let bus = parts.next().unwrap_or("0");
        let dev_func = parts.next().unwrap_or("0.0");
        let mut dev_func_parts = dev_func.split('.');
        let device = dev_func_parts.next().unwrap_or("0");
        let function = dev_func_parts.next().unwrap_or("0");

        let bus_dec = i32::from_str_radix(bus, 16).unwrap_or(0);
        let dev_dec = i32::from_str_radix(device, 16).unwrap_or(0);
        let func_dec = i32::from_str_radix(function, 16).unwrap_or(0);

        return Ok(format!("PCI:{bus_dec}:{dev_dec}:{func_dec}"));
    }

    error!("Could not find Nvidia GPU");
    Err("Could not find Nvidia GPU; try switching to hybrid mode first".to_string())
}

fn get_igpu_vendor() -> Option<String> {
    let output = Command::new("lspci").output().ok()?;
    if !output.status.success() {
        return None;
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    for line in stdout.lines() {
        let is_gpu = line.contains("VGA compatible controller") || line.contains("Display controller");
        if !is_gpu {
            continue;
        }
        if line.contains("Intel") {
            info!("Found Intel iGPU");
            return Some("intel".to_string());
        }
        if line.contains("ATI") || line.contains("AMD") || line.contains("AMD/ATI") {
            info!("Found AMD iGPU");
            return Some("amd".to_string());
        }
    }
    warn!("Could not find Intel or AMD iGPU");
    None
}

fn detect_display_manager() -> Option<DisplayManager> {
    let path = "/etc/systemd/system/display-manager.service";
    let content = fs::read_to_string(path).ok()?;
    for line in content.lines() {
        if let Some(rest) = line.strip_prefix("ExecStart=") {
            let binary = Path::new(rest.trim())
                .file_name()
                .and_then(|s| s.to_str())
                .unwrap_or("");
            let dm = DisplayManager::from_str(binary);
            if let Some(dm) = dm {
                info!("Found {} Display Manager", dm.as_str());
                return Some(dm);
            }
        }
    }
    warn!("Display Manager detection is not available");
    None
}

fn generate_xrandr_script(igpu_vendor: &str) -> String {
    let provider = if igpu_vendor == "intel" {
        "modesetting".to_string()
    } else if igpu_vendor == "amd" {
        get_amd_igpu_name().unwrap_or_else(|| "modesetting".to_string())
    } else {
        "modesetting".to_string()
    };

    NVIDIA_XRANDR_SCRIPT.replace("{}", &provider)
}

fn get_amd_igpu_name() -> Option<String> {
    if !Path::new("/usr/bin/xrandr").exists() {
        warn!("The 'xrandr' command is not available. Make sure the package is installed!");
        return None;
    }

    let output = Command::new("xrandr")
        .arg("--listproviders")
        .output()
        .ok()?;
    if !output.status.success() {
        warn!("Failed to run the 'xrandr' command.");
        return None;
    }

    let stdout = String::from_utf8_lossy(&output.stdout);

    for line in stdout.lines() {
        // Example provider line:
        // "Provider 0: id: 0x6c cap: 0x9, Source Output, Sink Offload name:NVIDIA-0"
        // We're interested in a provider whose name contains AMD/ATI.
        if line.contains("name:") && (line.contains("ATI") || line.contains("AMD")) {
            if let Some(idx) = line.find("name:") {
                let name = line[idx + "name:".len()..].trim();
                if !name.is_empty() {
                    return Some(name.to_string());
                }
            }
        }
    }

    warn!("Could not find AMD iGPU in 'xrandr' output.");
    None
}

fn rebuild_initramfs() -> Result<(), String> {
    let cmd = if Path::new("/ostree").exists() || Path::new("/sysroot/ostree").exists() {
        Some(vec!["rpm-ostree", "initramfs", "--enable", "--arg=--force"])
    } else if Path::new("/etc/debian_version").exists() {
        Some(vec!["update-initramfs", "-u", "-k", "all"])
    } else if Path::new("/etc/redhat-release").exists() || Path::new("/usr/bin/zypper").exists() {
        Some(vec!["dracut", "--force", "--regenerate-all"])
    } else if Path::new("/usr/lib/endeavouros-release").exists() && Path::new("/usr/bin/dracut").exists() {
        Some(vec!["dracut-rebuild"])
    } else if Path::new("/etc/altlinux-release").exists() {
        Some(vec!["make-initrd"])
    } else if Path::new("/etc/arch-release").exists() {
        Some(vec!["mkinitcpio", "-P"])
    } else {
        None
    };

    let Some(base_cmd) = cmd else {
        info!("No known initramfs tool detected; skipping initramfs rebuild");
        return Ok(());
    };

    info!("Rebuilding the initramfs...");
    let status = Command::new(base_cmd[0])
        .args(&base_cmd[1..])
        .status()
        .map_err(|e| format!("failed to run initramfs command: {e}"))?;

    if status.success() {
        info!("Successfully rebuilt the initramfs!");
        Ok(())
    } else {
        error!("An error occurred while rebuilding the initramfs");
        Err("initramfs rebuild failed".to_string())
    }
}

fn create_file(path: &str, content: &str, executable: bool) -> Result<(), String> {
    let p = Path::new(path);
    if let Some(parent) = p.parent() {
        if let Err(err) = fs::create_dir_all(parent) {
            return Err(format!("failed to create parent directory for {path}: {err}"));
        }
    }

    fs::write(path, content).map_err(|e| format!("failed to create file '{path}': {e}"))?;
    info!("Created file {path}");

    if executable {
        Command::new("chmod")
            .arg("+x")
            .arg(path)
            .status()
            .map_err(|e| format!("failed to add execution privilege to file {path}: {e}"))?;
    }

    Ok(())
}

